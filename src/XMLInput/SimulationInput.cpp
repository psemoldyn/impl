// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "SimulationInput.h"

// globalVals
// 

const globalVals::endTime_optional& globalVals::
endTime () const
{
  return this->endTime_;
}

globalVals::endTime_optional& globalVals::
endTime ()
{
  return this->endTime_;
}

void globalVals::
endTime (const endTime_type& x)
{
  this->endTime_.set (x);
}

void globalVals::
endTime (const endTime_optional& x)
{
  this->endTime_ = x;
}

const globalVals::deltaT_optional& globalVals::
deltaT () const
{
  return this->deltaT_;
}

globalVals::deltaT_optional& globalVals::
deltaT ()
{
  return this->deltaT_;
}

void globalVals::
deltaT (const deltaT_type& x)
{
  this->deltaT_.set (x);
}

void globalVals::
deltaT (const deltaT_optional& x)
{
  this->deltaT_ = x;
}

const globalVals::simType_optional& globalVals::
simType () const
{
  return this->simType_;
}

globalVals::simType_optional& globalVals::
simType ()
{
  return this->simType_;
}

void globalVals::
simType (const simType_type& x)
{
  this->simType_.set (x);
}

void globalVals::
simType (const simType_optional& x)
{
  this->simType_ = x;
}

const globalVals::applyTemp_optional& globalVals::
applyTemp () const
{
  return this->applyTemp_;
}

globalVals::applyTemp_optional& globalVals::
applyTemp ()
{
  return this->applyTemp_;
}

void globalVals::
applyTemp (const applyTemp_type& x)
{
  this->applyTemp_.set (x);
}

void globalVals::
applyTemp (const applyTemp_optional& x)
{
  this->applyTemp_ = x;
}

const globalVals::gravity_optional& globalVals::
gravity () const
{
  return this->gravity_;
}

globalVals::gravity_optional& globalVals::
gravity ()
{
  return this->gravity_;
}

void globalVals::
gravity (const gravity_type& x)
{
  this->gravity_.set (x);
}

void globalVals::
gravity (const gravity_optional& x)
{
  this->gravity_ = x;
}

const globalVals::boundaryType_optional& globalVals::
boundaryType () const
{
  return this->boundaryType_;
}

globalVals::boundaryType_optional& globalVals::
boundaryType ()
{
  return this->boundaryType_;
}

void globalVals::
boundaryType (const boundaryType_type& x)
{
  this->boundaryType_.set (x);
}

void globalVals::
boundaryType (const boundaryType_optional& x)
{
  this->boundaryType_ = x;
}

const globalVals::use3d_optional& globalVals::
use3d () const
{
  return this->use3d_;
}

globalVals::use3d_optional& globalVals::
use3d ()
{
  return this->use3d_;
}

void globalVals::
use3d (const use3d_type& x)
{
  this->use3d_.set (x);
}

void globalVals::
use3d (const use3d_optional& x)
{
  this->use3d_ = x;
}


// cuboidInput
// 

const cuboidInput::firstPosX_optional& cuboidInput::
firstPosX () const
{
  return this->firstPosX_;
}

cuboidInput::firstPosX_optional& cuboidInput::
firstPosX ()
{
  return this->firstPosX_;
}

void cuboidInput::
firstPosX (const firstPosX_type& x)
{
  this->firstPosX_.set (x);
}

void cuboidInput::
firstPosX (const firstPosX_optional& x)
{
  this->firstPosX_ = x;
}

const cuboidInput::firstPosY_optional& cuboidInput::
firstPosY () const
{
  return this->firstPosY_;
}

cuboidInput::firstPosY_optional& cuboidInput::
firstPosY ()
{
  return this->firstPosY_;
}

void cuboidInput::
firstPosY (const firstPosY_type& x)
{
  this->firstPosY_.set (x);
}

void cuboidInput::
firstPosY (const firstPosY_optional& x)
{
  this->firstPosY_ = x;
}

const cuboidInput::firstPosZ_optional& cuboidInput::
firstPosZ () const
{
  return this->firstPosZ_;
}

cuboidInput::firstPosZ_optional& cuboidInput::
firstPosZ ()
{
  return this->firstPosZ_;
}

void cuboidInput::
firstPosZ (const firstPosZ_type& x)
{
  this->firstPosZ_.set (x);
}

void cuboidInput::
firstPosZ (const firstPosZ_optional& x)
{
  this->firstPosZ_ = x;
}

const cuboidInput::startVelX_optional& cuboidInput::
startVelX () const
{
  return this->startVelX_;
}

cuboidInput::startVelX_optional& cuboidInput::
startVelX ()
{
  return this->startVelX_;
}

void cuboidInput::
startVelX (const startVelX_type& x)
{
  this->startVelX_.set (x);
}

void cuboidInput::
startVelX (const startVelX_optional& x)
{
  this->startVelX_ = x;
}

const cuboidInput::startVelY_optional& cuboidInput::
startVelY () const
{
  return this->startVelY_;
}

cuboidInput::startVelY_optional& cuboidInput::
startVelY ()
{
  return this->startVelY_;
}

void cuboidInput::
startVelY (const startVelY_type& x)
{
  this->startVelY_.set (x);
}

void cuboidInput::
startVelY (const startVelY_optional& x)
{
  this->startVelY_ = x;
}

const cuboidInput::startVelZ_optional& cuboidInput::
startVelZ () const
{
  return this->startVelZ_;
}

cuboidInput::startVelZ_optional& cuboidInput::
startVelZ ()
{
  return this->startVelZ_;
}

void cuboidInput::
startVelZ (const startVelZ_type& x)
{
  this->startVelZ_.set (x);
}

void cuboidInput::
startVelZ (const startVelZ_optional& x)
{
  this->startVelZ_ = x;
}

const cuboidInput::lengthX_optional& cuboidInput::
lengthX () const
{
  return this->lengthX_;
}

cuboidInput::lengthX_optional& cuboidInput::
lengthX ()
{
  return this->lengthX_;
}

void cuboidInput::
lengthX (const lengthX_type& x)
{
  this->lengthX_.set (x);
}

void cuboidInput::
lengthX (const lengthX_optional& x)
{
  this->lengthX_ = x;
}

const cuboidInput::lengthY_optional& cuboidInput::
lengthY () const
{
  return this->lengthY_;
}

cuboidInput::lengthY_optional& cuboidInput::
lengthY ()
{
  return this->lengthY_;
}

void cuboidInput::
lengthY (const lengthY_type& x)
{
  this->lengthY_.set (x);
}

void cuboidInput::
lengthY (const lengthY_optional& x)
{
  this->lengthY_ = x;
}

const cuboidInput::lengthZ_optional& cuboidInput::
lengthZ () const
{
  return this->lengthZ_;
}

cuboidInput::lengthZ_optional& cuboidInput::
lengthZ ()
{
  return this->lengthZ_;
}

void cuboidInput::
lengthZ (const lengthZ_type& x)
{
  this->lengthZ_.set (x);
}

void cuboidInput::
lengthZ (const lengthZ_optional& x)
{
  this->lengthZ_ = x;
}

const cuboidInput::mass_optional& cuboidInput::
mass () const
{
  return this->mass_;
}

cuboidInput::mass_optional& cuboidInput::
mass ()
{
  return this->mass_;
}

void cuboidInput::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

void cuboidInput::
mass (const mass_optional& x)
{
  this->mass_ = x;
}

const cuboidInput::dist_optional& cuboidInput::
dist () const
{
  return this->dist_;
}

cuboidInput::dist_optional& cuboidInput::
dist ()
{
  return this->dist_;
}

void cuboidInput::
dist (const dist_type& x)
{
  this->dist_.set (x);
}

void cuboidInput::
dist (const dist_optional& x)
{
  this->dist_ = x;
}

const cuboidInput::sigma_optional& cuboidInput::
sigma () const
{
  return this->sigma_;
}

cuboidInput::sigma_optional& cuboidInput::
sigma ()
{
  return this->sigma_;
}

void cuboidInput::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

void cuboidInput::
sigma (const sigma_optional& x)
{
  this->sigma_ = x;
}

const cuboidInput::epsilon_optional& cuboidInput::
epsilon () const
{
  return this->epsilon_;
}

cuboidInput::epsilon_optional& cuboidInput::
epsilon ()
{
  return this->epsilon_;
}

void cuboidInput::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

void cuboidInput::
epsilon (const epsilon_optional& x)
{
  this->epsilon_ = x;
}


// sphereInput
// 

const sphereInput::centerX_optional& sphereInput::
centerX () const
{
  return this->centerX_;
}

sphereInput::centerX_optional& sphereInput::
centerX ()
{
  return this->centerX_;
}

void sphereInput::
centerX (const centerX_type& x)
{
  this->centerX_.set (x);
}

void sphereInput::
centerX (const centerX_optional& x)
{
  this->centerX_ = x;
}

const sphereInput::centerY_optional& sphereInput::
centerY () const
{
  return this->centerY_;
}

sphereInput::centerY_optional& sphereInput::
centerY ()
{
  return this->centerY_;
}

void sphereInput::
centerY (const centerY_type& x)
{
  this->centerY_.set (x);
}

void sphereInput::
centerY (const centerY_optional& x)
{
  this->centerY_ = x;
}

const sphereInput::centerZ_optional& sphereInput::
centerZ () const
{
  return this->centerZ_;
}

sphereInput::centerZ_optional& sphereInput::
centerZ ()
{
  return this->centerZ_;
}

void sphereInput::
centerZ (const centerZ_type& x)
{
  this->centerZ_.set (x);
}

void sphereInput::
centerZ (const centerZ_optional& x)
{
  this->centerZ_ = x;
}

const sphereInput::startVelX_optional& sphereInput::
startVelX () const
{
  return this->startVelX_;
}

sphereInput::startVelX_optional& sphereInput::
startVelX ()
{
  return this->startVelX_;
}

void sphereInput::
startVelX (const startVelX_type& x)
{
  this->startVelX_.set (x);
}

void sphereInput::
startVelX (const startVelX_optional& x)
{
  this->startVelX_ = x;
}

const sphereInput::startVelY_optional& sphereInput::
startVelY () const
{
  return this->startVelY_;
}

sphereInput::startVelY_optional& sphereInput::
startVelY ()
{
  return this->startVelY_;
}

void sphereInput::
startVelY (const startVelY_type& x)
{
  this->startVelY_.set (x);
}

void sphereInput::
startVelY (const startVelY_optional& x)
{
  this->startVelY_ = x;
}

const sphereInput::startVelZ_optional& sphereInput::
startVelZ () const
{
  return this->startVelZ_;
}

sphereInput::startVelZ_optional& sphereInput::
startVelZ ()
{
  return this->startVelZ_;
}

void sphereInput::
startVelZ (const startVelZ_type& x)
{
  this->startVelZ_.set (x);
}

void sphereInput::
startVelZ (const startVelZ_optional& x)
{
  this->startVelZ_ = x;
}

const sphereInput::radius_optional& sphereInput::
radius () const
{
  return this->radius_;
}

sphereInput::radius_optional& sphereInput::
radius ()
{
  return this->radius_;
}

void sphereInput::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void sphereInput::
radius (const radius_optional& x)
{
  this->radius_ = x;
}

const sphereInput::mass_optional& sphereInput::
mass () const
{
  return this->mass_;
}

sphereInput::mass_optional& sphereInput::
mass ()
{
  return this->mass_;
}

void sphereInput::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

void sphereInput::
mass (const mass_optional& x)
{
  this->mass_ = x;
}

const sphereInput::dist_optional& sphereInput::
dist () const
{
  return this->dist_;
}

sphereInput::dist_optional& sphereInput::
dist ()
{
  return this->dist_;
}

void sphereInput::
dist (const dist_type& x)
{
  this->dist_.set (x);
}

void sphereInput::
dist (const dist_optional& x)
{
  this->dist_ = x;
}

const sphereInput::sigma_optional& sphereInput::
sigma () const
{
  return this->sigma_;
}

sphereInput::sigma_optional& sphereInput::
sigma ()
{
  return this->sigma_;
}

void sphereInput::
sigma (const sigma_type& x)
{
  this->sigma_.set (x);
}

void sphereInput::
sigma (const sigma_optional& x)
{
  this->sigma_ = x;
}

const sphereInput::epsilon_optional& sphereInput::
epsilon () const
{
  return this->epsilon_;
}

sphereInput::epsilon_optional& sphereInput::
epsilon ()
{
  return this->epsilon_;
}

void sphereInput::
epsilon (const epsilon_type& x)
{
  this->epsilon_.set (x);
}

void sphereInput::
epsilon (const epsilon_optional& x)
{
  this->epsilon_ = x;
}


// listInput
// 

const listInput::listParticleInput_optional& listInput::
listParticleInput () const
{
  return this->listParticleInput_;
}

listInput::listParticleInput_optional& listInput::
listParticleInput ()
{
  return this->listParticleInput_;
}

void listInput::
listParticleInput (const listParticleInput_type& x)
{
  this->listParticleInput_.set (x);
}

void listInput::
listParticleInput (const listParticleInput_optional& x)
{
  this->listParticleInput_ = x;
}

void listInput::
listParticleInput (::std::auto_ptr< listParticleInput_type > x)
{
  this->listParticleInput_.set (x);
}


// linkedCellInput
// 

const linkedCellInput::domainSizeX_optional& linkedCellInput::
domainSizeX () const
{
  return this->domainSizeX_;
}

linkedCellInput::domainSizeX_optional& linkedCellInput::
domainSizeX ()
{
  return this->domainSizeX_;
}

void linkedCellInput::
domainSizeX (const domainSizeX_type& x)
{
  this->domainSizeX_.set (x);
}

void linkedCellInput::
domainSizeX (const domainSizeX_optional& x)
{
  this->domainSizeX_ = x;
}

const linkedCellInput::domainSizeY_optional& linkedCellInput::
domainSizeY () const
{
  return this->domainSizeY_;
}

linkedCellInput::domainSizeY_optional& linkedCellInput::
domainSizeY ()
{
  return this->domainSizeY_;
}

void linkedCellInput::
domainSizeY (const domainSizeY_type& x)
{
  this->domainSizeY_.set (x);
}

void linkedCellInput::
domainSizeY (const domainSizeY_optional& x)
{
  this->domainSizeY_ = x;
}

const linkedCellInput::domainSizeZ_optional& linkedCellInput::
domainSizeZ () const
{
  return this->domainSizeZ_;
}

linkedCellInput::domainSizeZ_optional& linkedCellInput::
domainSizeZ ()
{
  return this->domainSizeZ_;
}

void linkedCellInput::
domainSizeZ (const domainSizeZ_type& x)
{
  this->domainSizeZ_.set (x);
}

void linkedCellInput::
domainSizeZ (const domainSizeZ_optional& x)
{
  this->domainSizeZ_ = x;
}

const linkedCellInput::rcut_optional& linkedCellInput::
rcut () const
{
  return this->rcut_;
}

linkedCellInput::rcut_optional& linkedCellInput::
rcut ()
{
  return this->rcut_;
}

void linkedCellInput::
rcut (const rcut_type& x)
{
  this->rcut_.set (x);
}

void linkedCellInput::
rcut (const rcut_optional& x)
{
  this->rcut_ = x;
}


// tempInput
// 

const tempInput::initTemp_optional& tempInput::
initTemp () const
{
  return this->initTemp_;
}

tempInput::initTemp_optional& tempInput::
initTemp ()
{
  return this->initTemp_;
}

void tempInput::
initTemp (const initTemp_type& x)
{
  this->initTemp_.set (x);
}

void tempInput::
initTemp (const initTemp_optional& x)
{
  this->initTemp_ = x;
}

const tempInput::stepsApply_optional& tempInput::
stepsApply () const
{
  return this->stepsApply_;
}

tempInput::stepsApply_optional& tempInput::
stepsApply ()
{
  return this->stepsApply_;
}

void tempInput::
stepsApply (const stepsApply_type& x)
{
  this->stepsApply_.set (x);
}

void tempInput::
stepsApply (const stepsApply_optional& x)
{
  this->stepsApply_ = x;
}

const tempInput::brown_optional& tempInput::
brown () const
{
  return this->brown_;
}

tempInput::brown_optional& tempInput::
brown ()
{
  return this->brown_;
}

void tempInput::
brown (const brown_type& x)
{
  this->brown_.set (x);
}

void tempInput::
brown (const brown_optional& x)
{
  this->brown_ = x;
}

const tempInput::deltaTemp_optional& tempInput::
deltaTemp () const
{
  return this->deltaTemp_;
}

tempInput::deltaTemp_optional& tempInput::
deltaTemp ()
{
  return this->deltaTemp_;
}

void tempInput::
deltaTemp (const deltaTemp_type& x)
{
  this->deltaTemp_.set (x);
}

void tempInput::
deltaTemp (const deltaTemp_optional& x)
{
  this->deltaTemp_ = x;
}

const tempInput::deltaTempSteps_optional& tempInput::
deltaTempSteps () const
{
  return this->deltaTempSteps_;
}

tempInput::deltaTempSteps_optional& tempInput::
deltaTempSteps ()
{
  return this->deltaTempSteps_;
}

void tempInput::
deltaTempSteps (const deltaTempSteps_type& x)
{
  this->deltaTempSteps_.set (x);
}

void tempInput::
deltaTempSteps (const deltaTempSteps_optional& x)
{
  this->deltaTempSteps_ = x;
}

const tempInput::targetTemp_optional& tempInput::
targetTemp () const
{
  return this->targetTemp_;
}

tempInput::targetTemp_optional& tempInput::
targetTemp ()
{
  return this->targetTemp_;
}

void tempInput::
targetTemp (const targetTemp_type& x)
{
  this->targetTemp_.set (x);
}

void tempInput::
targetTemp (const targetTemp_optional& x)
{
  this->targetTemp_ = x;
}


// outputData
// 

const outputData::filename_optional& outputData::
filename () const
{
  return this->filename_;
}

outputData::filename_optional& outputData::
filename ()
{
  return this->filename_;
}

void outputData::
filename (const filename_type& x)
{
  this->filename_.set (x);
}

void outputData::
filename (const filename_optional& x)
{
  this->filename_ = x;
}

void outputData::
filename (::std::auto_ptr< filename_type > x)
{
  this->filename_.set (x);
}

const outputData::writeFreq_optional& outputData::
writeFreq () const
{
  return this->writeFreq_;
}

outputData::writeFreq_optional& outputData::
writeFreq ()
{
  return this->writeFreq_;
}

void outputData::
writeFreq (const writeFreq_type& x)
{
  this->writeFreq_.set (x);
}

void outputData::
writeFreq (const writeFreq_optional& x)
{
  this->writeFreq_ = x;
}

const outputData::writeType_optional& outputData::
writeType () const
{
  return this->writeType_;
}

outputData::writeType_optional& outputData::
writeType ()
{
  return this->writeType_;
}

void outputData::
writeType (const writeType_type& x)
{
  this->writeType_.set (x);
}

void outputData::
writeType (const writeType_optional& x)
{
  this->writeType_ = x;
}


// particleInput
// 

const particleInput::cuboid_sequence& particleInput::
cuboid () const
{
  return this->cuboid_;
}

particleInput::cuboid_sequence& particleInput::
cuboid ()
{
  return this->cuboid_;
}

void particleInput::
cuboid (const cuboid_sequence& s)
{
  this->cuboid_ = s;
}

const particleInput::sphere_sequence& particleInput::
sphere () const
{
  return this->sphere_;
}

particleInput::sphere_sequence& particleInput::
sphere ()
{
  return this->sphere_;
}

void particleInput::
sphere (const sphere_sequence& s)
{
  this->sphere_ = s;
}

const particleInput::list_sequence& particleInput::
list () const
{
  return this->list_;
}

particleInput::list_sequence& particleInput::
list ()
{
  return this->list_;
}

void particleInput::
list (const list_sequence& s)
{
  this->list_ = s;
}


// simulationInput
// 

const simulationInput::global_type& simulationInput::
global () const
{
  return this->global_.get ();
}

simulationInput::global_type& simulationInput::
global ()
{
  return this->global_.get ();
}

void simulationInput::
global (const global_type& x)
{
  this->global_.set (x);
}

void simulationInput::
global (::std::auto_ptr< global_type > x)
{
  this->global_.set (x);
}

const simulationInput::particles_type& simulationInput::
particles () const
{
  return this->particles_.get ();
}

simulationInput::particles_type& simulationInput::
particles ()
{
  return this->particles_.get ();
}

void simulationInput::
particles (const particles_type& x)
{
  this->particles_.set (x);
}

void simulationInput::
particles (::std::auto_ptr< particles_type > x)
{
  this->particles_.set (x);
}

const simulationInput::linkedCell_type& simulationInput::
linkedCell () const
{
  return this->linkedCell_.get ();
}

simulationInput::linkedCell_type& simulationInput::
linkedCell ()
{
  return this->linkedCell_.get ();
}

void simulationInput::
linkedCell (const linkedCell_type& x)
{
  this->linkedCell_.set (x);
}

void simulationInput::
linkedCell (::std::auto_ptr< linkedCell_type > x)
{
  this->linkedCell_.set (x);
}

const simulationInput::temp_type& simulationInput::
temp () const
{
  return this->temp_.get ();
}

simulationInput::temp_type& simulationInput::
temp ()
{
  return this->temp_.get ();
}

void simulationInput::
temp (const temp_type& x)
{
  this->temp_.set (x);
}

void simulationInput::
temp (::std::auto_ptr< temp_type > x)
{
  this->temp_.set (x);
}

const simulationInput::outData_type& simulationInput::
outData () const
{
  return this->outData_.get ();
}

simulationInput::outData_type& simulationInput::
outData ()
{
  return this->outData_.get ();
}

void simulationInput::
outData (const outData_type& x)
{
  this->outData_.set (x);
}

void simulationInput::
outData (::std::auto_ptr< outData_type > x)
{
  this->outData_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// globalVals
//

globalVals::
globalVals ()
: ::xml_schema::type (),
  endTime_ (::xml_schema::flags(), this),
  deltaT_ (::xml_schema::flags(), this),
  simType_ (::xml_schema::flags(), this),
  applyTemp_ (::xml_schema::flags(), this),
  gravity_ (::xml_schema::flags(), this),
  boundaryType_ (::xml_schema::flags(), this),
  use3d_ (::xml_schema::flags(), this)
{
}

globalVals::
globalVals (const globalVals& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  endTime_ (x.endTime_, f, this),
  deltaT_ (x.deltaT_, f, this),
  simType_ (x.simType_, f, this),
  applyTemp_ (x.applyTemp_, f, this),
  gravity_ (x.gravity_, f, this),
  boundaryType_ (x.boundaryType_, f, this),
  use3d_ (x.use3d_, f, this)
{
}

globalVals::
globalVals (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  endTime_ (f, this),
  deltaT_ (f, this),
  simType_ (f, this),
  applyTemp_ (f, this),
  gravity_ (f, this),
  boundaryType_ (f, this),
  use3d_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void globalVals::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "endTime" && n.namespace_ ().empty ())
    {
      this->endTime_.set (endTime_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "deltaT" && n.namespace_ ().empty ())
    {
      this->deltaT_.set (deltaT_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "simType" && n.namespace_ ().empty ())
    {
      this->simType_.set (simType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "applyTemp" && n.namespace_ ().empty ())
    {
      this->applyTemp_.set (applyTemp_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "gravity" && n.namespace_ ().empty ())
    {
      this->gravity_.set (gravity_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "boundaryType" && n.namespace_ ().empty ())
    {
      this->boundaryType_.set (boundaryType_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "use3d" && n.namespace_ ().empty ())
    {
      this->use3d_.set (use3d_traits::create (i, f, this));
      continue;
    }
  }
}

globalVals* globalVals::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class globalVals (*this, f, c);
}

globalVals& globalVals::
operator= (const globalVals& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->endTime_ = x.endTime_;
    this->deltaT_ = x.deltaT_;
    this->simType_ = x.simType_;
    this->applyTemp_ = x.applyTemp_;
    this->gravity_ = x.gravity_;
    this->boundaryType_ = x.boundaryType_;
    this->use3d_ = x.use3d_;
  }

  return *this;
}

globalVals::
~globalVals ()
{
}

// cuboidInput
//

cuboidInput::
cuboidInput ()
: ::xml_schema::type (),
  firstPosX_ (::xml_schema::flags(), this),
  firstPosY_ (::xml_schema::flags(), this),
  firstPosZ_ (::xml_schema::flags(), this),
  startVelX_ (::xml_schema::flags(), this),
  startVelY_ (::xml_schema::flags(), this),
  startVelZ_ (::xml_schema::flags(), this),
  lengthX_ (::xml_schema::flags(), this),
  lengthY_ (::xml_schema::flags(), this),
  lengthZ_ (::xml_schema::flags(), this),
  mass_ (::xml_schema::flags(), this),
  dist_ (::xml_schema::flags(), this),
  sigma_ (::xml_schema::flags(), this),
  epsilon_ (::xml_schema::flags(), this)
{
}

cuboidInput::
cuboidInput (const cuboidInput& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  firstPosX_ (x.firstPosX_, f, this),
  firstPosY_ (x.firstPosY_, f, this),
  firstPosZ_ (x.firstPosZ_, f, this),
  startVelX_ (x.startVelX_, f, this),
  startVelY_ (x.startVelY_, f, this),
  startVelZ_ (x.startVelZ_, f, this),
  lengthX_ (x.lengthX_, f, this),
  lengthY_ (x.lengthY_, f, this),
  lengthZ_ (x.lengthZ_, f, this),
  mass_ (x.mass_, f, this),
  dist_ (x.dist_, f, this),
  sigma_ (x.sigma_, f, this),
  epsilon_ (x.epsilon_, f, this)
{
}

cuboidInput::
cuboidInput (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  firstPosX_ (f, this),
  firstPosY_ (f, this),
  firstPosZ_ (f, this),
  startVelX_ (f, this),
  startVelY_ (f, this),
  startVelZ_ (f, this),
  lengthX_ (f, this),
  lengthY_ (f, this),
  lengthZ_ (f, this),
  mass_ (f, this),
  dist_ (f, this),
  sigma_ (f, this),
  epsilon_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void cuboidInput::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "firstPosX" && n.namespace_ ().empty ())
    {
      this->firstPosX_.set (firstPosX_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "firstPosY" && n.namespace_ ().empty ())
    {
      this->firstPosY_.set (firstPosY_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "firstPosZ" && n.namespace_ ().empty ())
    {
      this->firstPosZ_.set (firstPosZ_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "startVelX" && n.namespace_ ().empty ())
    {
      this->startVelX_.set (startVelX_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "startVelY" && n.namespace_ ().empty ())
    {
      this->startVelY_.set (startVelY_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "startVelZ" && n.namespace_ ().empty ())
    {
      this->startVelZ_.set (startVelZ_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lengthX" && n.namespace_ ().empty ())
    {
      this->lengthX_.set (lengthX_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lengthY" && n.namespace_ ().empty ())
    {
      this->lengthY_.set (lengthY_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "lengthZ" && n.namespace_ ().empty ())
    {
      this->lengthZ_.set (lengthZ_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      this->mass_.set (mass_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dist" && n.namespace_ ().empty ())
    {
      this->dist_.set (dist_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      this->sigma_.set (sigma_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      this->epsilon_.set (epsilon_traits::create (i, f, this));
      continue;
    }
  }
}

cuboidInput* cuboidInput::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboidInput (*this, f, c);
}

cuboidInput& cuboidInput::
operator= (const cuboidInput& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->firstPosX_ = x.firstPosX_;
    this->firstPosY_ = x.firstPosY_;
    this->firstPosZ_ = x.firstPosZ_;
    this->startVelX_ = x.startVelX_;
    this->startVelY_ = x.startVelY_;
    this->startVelZ_ = x.startVelZ_;
    this->lengthX_ = x.lengthX_;
    this->lengthY_ = x.lengthY_;
    this->lengthZ_ = x.lengthZ_;
    this->mass_ = x.mass_;
    this->dist_ = x.dist_;
    this->sigma_ = x.sigma_;
    this->epsilon_ = x.epsilon_;
  }

  return *this;
}

cuboidInput::
~cuboidInput ()
{
}

// sphereInput
//

sphereInput::
sphereInput ()
: ::xml_schema::type (),
  centerX_ (::xml_schema::flags(), this),
  centerY_ (::xml_schema::flags(), this),
  centerZ_ (::xml_schema::flags(), this),
  startVelX_ (::xml_schema::flags(), this),
  startVelY_ (::xml_schema::flags(), this),
  startVelZ_ (::xml_schema::flags(), this),
  radius_ (::xml_schema::flags(), this),
  mass_ (::xml_schema::flags(), this),
  dist_ (::xml_schema::flags(), this),
  sigma_ (::xml_schema::flags(), this),
  epsilon_ (::xml_schema::flags(), this)
{
}

sphereInput::
sphereInput (const sphereInput& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  centerX_ (x.centerX_, f, this),
  centerY_ (x.centerY_, f, this),
  centerZ_ (x.centerZ_, f, this),
  startVelX_ (x.startVelX_, f, this),
  startVelY_ (x.startVelY_, f, this),
  startVelZ_ (x.startVelZ_, f, this),
  radius_ (x.radius_, f, this),
  mass_ (x.mass_, f, this),
  dist_ (x.dist_, f, this),
  sigma_ (x.sigma_, f, this),
  epsilon_ (x.epsilon_, f, this)
{
}

sphereInput::
sphereInput (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  centerX_ (f, this),
  centerY_ (f, this),
  centerZ_ (f, this),
  startVelX_ (f, this),
  startVelY_ (f, this),
  startVelZ_ (f, this),
  radius_ (f, this),
  mass_ (f, this),
  dist_ (f, this),
  sigma_ (f, this),
  epsilon_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void sphereInput::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "centerX" && n.namespace_ ().empty ())
    {
      this->centerX_.set (centerX_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "centerY" && n.namespace_ ().empty ())
    {
      this->centerY_.set (centerY_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "centerZ" && n.namespace_ ().empty ())
    {
      this->centerZ_.set (centerZ_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "startVelX" && n.namespace_ ().empty ())
    {
      this->startVelX_.set (startVelX_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "startVelY" && n.namespace_ ().empty ())
    {
      this->startVelY_.set (startVelY_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "startVelZ" && n.namespace_ ().empty ())
    {
      this->startVelZ_.set (startVelZ_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      this->radius_.set (radius_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      this->mass_.set (mass_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "dist" && n.namespace_ ().empty ())
    {
      this->dist_.set (dist_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "sigma" && n.namespace_ ().empty ())
    {
      this->sigma_.set (sigma_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "epsilon" && n.namespace_ ().empty ())
    {
      this->epsilon_.set (epsilon_traits::create (i, f, this));
      continue;
    }
  }
}

sphereInput* sphereInput::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sphereInput (*this, f, c);
}

sphereInput& sphereInput::
operator= (const sphereInput& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->centerX_ = x.centerX_;
    this->centerY_ = x.centerY_;
    this->centerZ_ = x.centerZ_;
    this->startVelX_ = x.startVelX_;
    this->startVelY_ = x.startVelY_;
    this->startVelZ_ = x.startVelZ_;
    this->radius_ = x.radius_;
    this->mass_ = x.mass_;
    this->dist_ = x.dist_;
    this->sigma_ = x.sigma_;
    this->epsilon_ = x.epsilon_;
  }

  return *this;
}

sphereInput::
~sphereInput ()
{
}

// listInput
//

listInput::
listInput ()
: ::xml_schema::type (),
  listParticleInput_ (::xml_schema::flags(), this)
{
}

listInput::
listInput (const listInput& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  listParticleInput_ (x.listParticleInput_, f, this)
{
}

listInput::
listInput (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  listParticleInput_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void listInput::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "listParticleInput" && n.namespace_ ().empty ())
    {
      this->listParticleInput_.set (listParticleInput_traits::create (i, f, this));
      continue;
    }
  }
}

listInput* listInput::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class listInput (*this, f, c);
}

listInput& listInput::
operator= (const listInput& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->listParticleInput_ = x.listParticleInput_;
  }

  return *this;
}

listInput::
~listInput ()
{
}

// linkedCellInput
//

linkedCellInput::
linkedCellInput ()
: ::xml_schema::type (),
  domainSizeX_ (::xml_schema::flags(), this),
  domainSizeY_ (::xml_schema::flags(), this),
  domainSizeZ_ (::xml_schema::flags(), this),
  rcut_ (::xml_schema::flags(), this)
{
}

linkedCellInput::
linkedCellInput (const linkedCellInput& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  domainSizeX_ (x.domainSizeX_, f, this),
  domainSizeY_ (x.domainSizeY_, f, this),
  domainSizeZ_ (x.domainSizeZ_, f, this),
  rcut_ (x.rcut_, f, this)
{
}

linkedCellInput::
linkedCellInput (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  domainSizeX_ (f, this),
  domainSizeY_ (f, this),
  domainSizeZ_ (f, this),
  rcut_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void linkedCellInput::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "domainSizeX" && n.namespace_ ().empty ())
    {
      this->domainSizeX_.set (domainSizeX_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "domainSizeY" && n.namespace_ ().empty ())
    {
      this->domainSizeY_.set (domainSizeY_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "domainSizeZ" && n.namespace_ ().empty ())
    {
      this->domainSizeZ_.set (domainSizeZ_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "rcut" && n.namespace_ ().empty ())
    {
      this->rcut_.set (rcut_traits::create (i, f, this));
      continue;
    }
  }
}

linkedCellInput* linkedCellInput::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class linkedCellInput (*this, f, c);
}

linkedCellInput& linkedCellInput::
operator= (const linkedCellInput& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->domainSizeX_ = x.domainSizeX_;
    this->domainSizeY_ = x.domainSizeY_;
    this->domainSizeZ_ = x.domainSizeZ_;
    this->rcut_ = x.rcut_;
  }

  return *this;
}

linkedCellInput::
~linkedCellInput ()
{
}

// tempInput
//

tempInput::
tempInput ()
: ::xml_schema::type (),
  initTemp_ (::xml_schema::flags(), this),
  stepsApply_ (::xml_schema::flags(), this),
  brown_ (::xml_schema::flags(), this),
  deltaTemp_ (::xml_schema::flags(), this),
  deltaTempSteps_ (::xml_schema::flags(), this),
  targetTemp_ (::xml_schema::flags(), this)
{
}

tempInput::
tempInput (const tempInput& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  initTemp_ (x.initTemp_, f, this),
  stepsApply_ (x.stepsApply_, f, this),
  brown_ (x.brown_, f, this),
  deltaTemp_ (x.deltaTemp_, f, this),
  deltaTempSteps_ (x.deltaTempSteps_, f, this),
  targetTemp_ (x.targetTemp_, f, this)
{
}

tempInput::
tempInput (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  initTemp_ (f, this),
  stepsApply_ (f, this),
  brown_ (f, this),
  deltaTemp_ (f, this),
  deltaTempSteps_ (f, this),
  targetTemp_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void tempInput::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "initTemp" && n.namespace_ ().empty ())
    {
      this->initTemp_.set (initTemp_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "stepsApply" && n.namespace_ ().empty ())
    {
      this->stepsApply_.set (stepsApply_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "brown" && n.namespace_ ().empty ())
    {
      this->brown_.set (brown_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "deltaTemp" && n.namespace_ ().empty ())
    {
      this->deltaTemp_.set (deltaTemp_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "deltaTempSteps" && n.namespace_ ().empty ())
    {
      this->deltaTempSteps_.set (deltaTempSteps_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "targetTemp" && n.namespace_ ().empty ())
    {
      this->targetTemp_.set (targetTemp_traits::create (i, f, this));
      continue;
    }
  }
}

tempInput* tempInput::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class tempInput (*this, f, c);
}

tempInput& tempInput::
operator= (const tempInput& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->initTemp_ = x.initTemp_;
    this->stepsApply_ = x.stepsApply_;
    this->brown_ = x.brown_;
    this->deltaTemp_ = x.deltaTemp_;
    this->deltaTempSteps_ = x.deltaTempSteps_;
    this->targetTemp_ = x.targetTemp_;
  }

  return *this;
}

tempInput::
~tempInput ()
{
}

// outputData
//

outputData::
outputData ()
: ::xml_schema::type (),
  filename_ (::xml_schema::flags(), this),
  writeFreq_ (::xml_schema::flags(), this),
  writeType_ (::xml_schema::flags(), this)
{
}

outputData::
outputData (const outputData& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  filename_ (x.filename_, f, this),
  writeFreq_ (x.writeFreq_, f, this),
  writeType_ (x.writeType_, f, this)
{
}

outputData::
outputData (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  filename_ (f, this),
  writeFreq_ (f, this),
  writeType_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
    this->parse (p, f);
  }
}

void outputData::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "filename" && n.namespace_ ().empty ())
    {
      this->filename_.set (filename_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "writeFreq" && n.namespace_ ().empty ())
    {
      this->writeFreq_.set (writeFreq_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "writeType" && n.namespace_ ().empty ())
    {
      this->writeType_.set (writeType_traits::create (i, f, this));
      continue;
    }
  }
}

outputData* outputData::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class outputData (*this, f, c);
}

outputData& outputData::
operator= (const outputData& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->filename_ = x.filename_;
    this->writeFreq_ = x.writeFreq_;
    this->writeType_ = x.writeType_;
  }

  return *this;
}

outputData::
~outputData ()
{
}

// particleInput
//

particleInput::
particleInput ()
: ::xml_schema::type (),
  cuboid_ (::xml_schema::flags(), this),
  sphere_ (::xml_schema::flags(), this),
  list_ (::xml_schema::flags(), this)
{
}

particleInput::
particleInput (const particleInput& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  cuboid_ (x.cuboid_, f, this),
  sphere_ (x.sphere_, f, this),
  list_ (x.list_, f, this)
{
}

particleInput::
particleInput (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  cuboid_ (f, this),
  sphere_ (f, this),
  list_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void particleInput::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element (/*false*/))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // cuboid
    //
    if (n.name () == "cuboid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cuboid_type > r (
        cuboid_traits::create (i, f, this));

      this->cuboid_.push_back (r);
      continue;
    }

    // sphere
    //
    if (n.name () == "sphere" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< sphere_type > r (
        sphere_traits::create (i, f, this));

      this->sphere_.push_back (r);
      continue;
    }

    // list
    //
    if (n.name () == "list" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< list_type > r (
        list_traits::create (i, f, this));

      this->list_.push_back (r);
      continue;
    }

    break;
  }
}

particleInput* particleInput::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particleInput (*this, f, c);
}

particleInput& particleInput::
operator= (const particleInput& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->cuboid_ = x.cuboid_;
    this->sphere_ = x.sphere_;
    this->list_ = x.list_;
  }

  return *this;
}

particleInput::
~particleInput ()
{
}

// simulationInput
//

simulationInput::
simulationInput (const global_type& global,
                 const particles_type& particles,
                 const linkedCell_type& linkedCell,
                 const temp_type& temp,
                 const outData_type& outData)
: ::xml_schema::type (),
  global_ (global, ::xml_schema::flags(), this),
  particles_ (particles, ::xml_schema::flags(), this),
  linkedCell_ (linkedCell, ::xml_schema::flags(), this),
  temp_ (temp, ::xml_schema::flags(), this),
  outData_ (outData, ::xml_schema::flags(), this)
{
}

simulationInput::
simulationInput (::std::auto_ptr< global_type > global,
                 ::std::auto_ptr< particles_type > particles,
                 ::std::auto_ptr< linkedCell_type > linkedCell,
                 ::std::auto_ptr< temp_type > temp,
                 ::std::auto_ptr< outData_type > outData)
: ::xml_schema::type (),
  global_ (global, ::xml_schema::flags(),this),
  particles_ (particles, ::xml_schema::flags(),this),
  linkedCell_ (linkedCell, ::xml_schema::flags(),this),
  temp_ (temp, ::xml_schema::flags(),this),
  outData_ (outData, ::xml_schema::flags(),this)
{
}

simulationInput::
simulationInput (const simulationInput& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  global_ (x.global_, f, this),
  particles_ (x.particles_, f, this),
  linkedCell_ (x.linkedCell_, f, this),
  temp_ (x.temp_, f, this),
  outData_ (x.outData_, f, this)
{
}

simulationInput::
simulationInput (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  global_ (f, this),
  particles_ (f, this),
  linkedCell_ (f, this),
  temp_ (f, this),
  outData_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
    this->parse (p, f);
  }
}

void simulationInput::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element (/*false*/))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // global
    //
    if (n.name () == "global" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< global_type > r (
        global_traits::create (i, f, this));

      if (!global_.present ())
      {
        this->global_.set (r);
        continue;
      }
    }

    // particles
    //
    if (n.name () == "particles" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< particles_type > r (
        particles_traits::create (i, f, this));

      if (!particles_.present ())
      {
        this->particles_.set (r);
        continue;
      }
    }

    // linkedCell
    //
    if (n.name () == "linkedCell" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< linkedCell_type > r (
        linkedCell_traits::create (i, f, this));

      if (!linkedCell_.present ())
      {
        this->linkedCell_.set (r);
        continue;
      }
    }

    // temp
    //
    if (n.name () == "temp" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< temp_type > r (
        temp_traits::create (i, f, this));

      if (!temp_.present ())
      {
        this->temp_.set (r);
        continue;
      }
    }

    // outData
    //
    if (n.name () == "outData" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< outData_type > r (
        outData_traits::create (i, f, this));

      if (!outData_.present ())
      {
        this->outData_.set (r);
        continue;
      }
    }

    break;
  }

  if (!global_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "global",
      "");
  }

  if (!particles_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "particles",
      "");
  }

  if (!linkedCell_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "linkedCell",
      "");
  }

  if (!temp_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "temp",
      "");
  }

  if (!outData_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "outData",
      "");
  }
}

simulationInput* simulationInput::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simulationInput (*this, f, c);
}

simulationInput& simulationInput::
operator= (const simulationInput& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->global_ = x.global_;
    this->particles_ = x.particles_;
    this->linkedCell_ = x.linkedCell_;
    this->temp_ = x.temp_;
    this->outData_ = x.outData_;
  }

  return *this;
}

simulationInput::
~simulationInput ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::simulationInput >
sim (const ::std::string& u,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::simulationInput > (
    ::sim (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulationInput >
sim (const ::std::string& u,
     ::xml_schema::error_handler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::simulationInput > (
    ::sim (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulationInput >
sim (const ::std::string& u,
     ::xercesc::DOMErrorHandler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::simulationInput > (
    ::sim (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulationInput >
sim (::std::istream& is,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::sim (isrc, f, p);
}

::std::auto_ptr< ::simulationInput >
sim (::std::istream& is,
     ::xml_schema::error_handler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::sim (isrc, h, f, p);
}

::std::auto_ptr< ::simulationInput >
sim (::std::istream& is,
     ::xercesc::DOMErrorHandler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::sim (isrc, h, f, p);
}

::std::auto_ptr< ::simulationInput >
sim (::std::istream& is,
     const ::std::string& sid,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::sim (isrc, f, p);
}

::std::auto_ptr< ::simulationInput >
sim (::std::istream& is,
     const ::std::string& sid,
     ::xml_schema::error_handler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::sim (isrc, h, f, p);
}

::std::auto_ptr< ::simulationInput >
sim (::std::istream& is,
     const ::std::string& sid,
     ::xercesc::DOMErrorHandler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::sim (isrc, h, f, p);
}

::std::auto_ptr< ::simulationInput >
sim (::xercesc::InputSource& i,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::simulationInput > (
    ::sim (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulationInput >
sim (::xercesc::InputSource& i,
     ::xml_schema::error_handler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::simulationInput > (
    ::sim (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulationInput >
sim (::xercesc::InputSource& i,
     ::xercesc::DOMErrorHandler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::simulationInput > (
    ::sim (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::simulationInput >
sim (const ::xercesc::DOMDocument& doc,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::simulationInput > (
      ::sim (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "sim" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::simulationInput > r (
      ::xsd::cxx::tree::traits< ::simulationInput, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "sim",
    "");
}

::std::auto_ptr< ::simulationInput >
sim (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
     ::xml_schema::flags f,
     const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "sim" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::simulationInput > r (
      ::xsd::cxx::tree::traits< ::simulationInput, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "sim",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

